---
output: github_document
bibliography: [./inst/REFERENCES.bib]
biblio-style: apalike
link-citations: yes
editor_options: 
  canonical: true
  markdown: 
    wrap: 80
    references: 
      location: section
---

```{r, include = FALSE}
source(file.path(usethis::proj_get(), "vignettes",  "_common.R"))
```

# `decorators` <img src="https://raw.githubusercontent.com/tidylab/decorators/master/pkgdown/logo.png" align="right" height="75"/>

<!-- badges: start -->

[![CRAN
status](https://www.r-pkg.org/badges/version/decorators)](https://CRAN.R-project.org/package=decorators)
[![R build
status](https://github.com/tidylab/decorators/workflows/R-CMD-check/badge.svg)](https://github.com/tidylab/decorators/actions)
[![codecov](https://codecov.io/gh/tidylab/decorators/branch/master/graph/badge.svg?token=U6FL5N32FL)](https://codecov.io/gh/tidylab/decorators)

<!-- badges: end -->


## Introduction

<!-- Problem statement -->



A decorator is a function that receives a function, extends its behaviour, and
returned the altered function. Any caller that uses the decorated function uses
the same interface as it were the original, undecorated function.

The `decorators` package provides information and decorators 

(1) Enhancing the response of a function as it sends data to a second component; and
(2) Supporting multiple optional behaviours. 

An example of the first use is a timer decorator that runs a function, returns
the original functionâ€™s result and outputs its execution time on the console. 
An example of the second use is a decorator that during
run time tests whether the caller has passed input arguments of a particular
class to the function. Decorators can reduce execution time, say by 'memoisation', or reduce
bugs by adding defensive programming routines.


## Decorators Violate the Single-Responsibility Principle

```{r child="vignettes/excerpts/single-responsibility-principle.Rmd"}
```

## Decorator Defenition

> A decorator is a function that takes another function and extends the behavior of the latter function without explicitly modifying it.

Reformulating the definition of a decorator we 

1. A decorator receives a function and returns a function
2. The original function and the decorated function are called in the same way
3. The decoration alters the behaviour of the original function. The behaviour alternation may change: 
    * The execution time of the function;
    * The returned value/data-structure;
    * The handling of unusual conditions, including errors and warnings. For
    instance, converting a runtime error into an exception;
    * 
    * A combination of the above.
    
A common structure of decorators is

```{r, echo=TRUE, eval=FALSE}

```

## Example: `time_it` decorator

```{r, echo=TRUE}
# Running the original Sys.sleep() produces no output
Sys.sleep(0.1)

# Decorating the Sys.sleep() with time_it() measures Sys.sleep() execution time 
# and outputs the measurement   
Sys.sleep <- decorators::time_it(base::Sys.sleep)
Sys.sleep(0.1)
```    

## Installation

You can install the released version of `decorators` from CRAN with:

``` r
install.packages("decorators")
```

And the development version from GitHub with:

``` r
# install.packages("devtools")
devtools::install_github("tidylab/decorators")
```
